(*
### Currently Completely BS EBNF:

My next effort will be to formally specify a context free grammar so that
I have an actual yardstick to aim at for the parser.

Again, currently, this EBNF is still a work in progress.
*)
(* Types and Declarations *)
Constraint         = Identifier, "_=", "{", { Field, "," }, "}".
Impl               = [GenericDecl], ["`",] Identifier, "^=", "{", { Assignment, ";" }, "}".
Enum               = Identifier, "~=", "{", { EnumPattern, "," }, "}".
EnumPattern        = Identifier, "(", TypeConstraints, ")".
TypeConstraints    = [[Identifier,] "`", [ ("&" | "*" ,) ] ] Identifier, { ( "+", Identifier ) | ( "|", Identifier ) }.
GenericDecl        = "<", Generics, ">", ":".
Generics           = { Identifier, ":", TypeConstraints [, "," ] }.
Type               = [ [ Identifier , ]"`",["&"|"*",] ] [ Identifier, ] ":".

(* Scopes *)
EagerScope         = [Type,] [ScopeType,] "{", [{Statement,";",}] Statement,[";"]"}", ";". (* TODO: ungeneralize Statement *)
LazyScope          = [Type,] [ScopeType,] "{", [{Statement,";",}]"}", ";".
MatchScope         = [Type,] [ScopeType,] "{", [[{[Pattern,][",",Expression],["=>",Expression],";"},] {[Pattern,][",",Expression,"=>",]Expression,[";"]} "}", ";".
ScopeType          = "~"|[ Identifier,]"`".

(* Functions *)
FnArgs             = RegFnArgs | InfixFnArgs.
RegFnArgs          = "\", [GenericDecl , ] Parameters, "->" .
InfixFnArgs        = "\:", [GenericDecl , ] Parameters, "->" .
Parameters         = Parameter, { "," , Parameter }.
Parameter          = Identifier, [":", Type, [":", DefaultValue]].
DefaultValue       = Literal | Expression.
FunctionDecl       = (RegFnArgs | InfixFnArgs), Expression.

(* Statements *)
Expression         = FunctionCall | Operation | Scope | FnArgs | Pattern | Loop | StreamIteration | FunctionDecl | Use.
ReturnStatement    = "<-", { Expression, ",", } ";".
Assignment         = [GenericDecl,] [Type,] Identifier, "=", Expression, ";".

(* Expressions *)  
FunctionCall       = Identifier, { { " " | "\n" | "\t" | "\r" | "\f" | "\b" }, Argument, }.
Operation          = Expression, Operator, Expression.
Pattern            = Identifier, "(", PatternConstraints, ")".
PatternConstraints = Literal | ([[Identifier,]"`",["&"|"*",] ] Identifier, { ( "+", Identifier ) | ( "|", Identifier ) }).
Argument           = Literal | Expression | Identifier | Pattern.
Use                = "use", String, Expression.

(* Control Structures *)
ThenElse           = Condition, "=>", Expression, ["!>", Expression].
Loop               = Condition|Iterable, ">>>", FnArgs, Expression.
StreamIteration    = Stream|Actor, "@>>", FnArgs, Expression. (* TODO: be more specific about FnArgs here *)
SendToStream       = Stream|Actor, "<@", Expression.
ResponsePattern    = Stream|Actor, "@>", FnArgs, Expression. (* TODO: be more specific about FnArgs here *)

(* Literals and Identifiers *)
Literal            = Integer | String | Float | Boolean.
Identifier         = Letter, { Letter | Digit | "_" }.
Operator           = "=", "+", "-", "/", "%",
                     "!", "!=", "==", "<=", ">=",
                     "=", "<", ">", "||", "&&",
                     "|", ">>", "<<",
                     (*above are standard stuff, you should recognize & * ? from below also*)
                     "\\", "\\:", "|>", "<-", "->", "...",
                     "~", "?", "&", "*", "`",
                     "|=", "^=", "~=",
                     ">>>", ">>|", ">>!", (* while continue break, continue and break can be given values to return matching scope return type *)
                     "=>", "!>",
                     "<@", "@", "@>", "@>>",
                     ":", ",", ";",
                     "#",

(* Miscellaneous *)
Comment            = LineComment | BlockComment.
LineComment        = "//", { AnyChar }.
BlockComment       = "/*", { AnyChar }, "*/".

(* File Structure *)
File               = { Declaration | Use } Expression.
Declaration        = TypeDef | FunctionDecl | VariableDecl.
VariableDecl       = Identifier, "=", Expression.

(* Enclosures *)
Enclosure          = "(", Expression, ")" | "[", ListItems, "]" | Scope.
        (*enclosers: &[("<", ">"), ("#<", ">"), ("$[","]")],*)
Tuple              = "[" Parameters, "]".
SetItems           = "{" { Assignment, "," } "}".
